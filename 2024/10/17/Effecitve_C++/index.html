<!DOCTYPE html>
<html lang="zh-Hans">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Effecitve_C++(个人总结向)" />
    <meta name="hexo-theme-A4" content="v2.0.0" />
    <link rel="alternate icon" type="image/webp" href="/img/avatar.png">
    <title>Floki</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Regular/result.css' /> 
<meta name="generator" content="Hexo 8.1.1"></head>
    
    

    
    



    

    
    




    
    


    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            
                <div class="left-toc-container">
                    <nav id="toc" class="bs-docs-sidebar"></nav>
                </div>
            
        
        <div class="paper">

            

            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 0; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/img/avatar.png" 
        />
        <div class="header-content">
            <a class="logo" href="/">Floki</a> 
            <span class="description">一个写作爱好者的在线笔记本</span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">🖼️首页</a></li>
            
        
            
                <li><a href="/list/">📚文章</a></li>
            
        
            
                <li><a href="/about/">🐈️关于</a></li>
            
        
            
                <li><a href="/tags/">🏔️标签</a></li>
            
        
            
                <li><a href="/categories/">🎲分类</a></li>
            
        
            
                <li><a href="/now/">🧊Now</a></li>
            
        
    </ul>
</div>

                    
                    

                    
                    

                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    Effecitve_C++(个人总结向)
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2026-01-02</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：16k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：68分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-%E5%B0%BD%E9%87%8F%E4%B8%8D%E4%BD%BF%E7%94%A8-define"><span class="post-toc-text">2.尽量不使用#define</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-%E5%B0%BD%E9%87%8F%E7%94%A8-const"><span class="post-toc-text">3.尽量用 const</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E5%89%8D%E5%BA%94%E8%AF%A5%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="post-toc-text">4.对象使用前应该被初始化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-%E4%BA%86%E8%A7%A3-C-%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0"><span class="post-toc-text">5.了解 C++默认生成的函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%89%B9%E7%A7%8D%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%A6%81%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="post-toc-text">6.不想使用特种函数，就要明确拒绝</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-%E7%BB%99%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%A3%B0%E6%98%8E-virtual"><span class="post-toc-text">7.给多态基类的析构声明 virtual</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E8%A6%81%E6%8A%9B%E5%BC%82%E5%B8%B8"><span class="post-toc-text">8.析构函数不要抛异常</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%87%8C%E9%9D%A2%E8%B0%83%E7%94%A8-virtual-%E5%87%BD%E6%95%B0"><span class="post-toc-text">9.不要在构造和析构里面调用 virtual 函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-%E8%AE%A9-operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E8%87%AA%E8%BA%AB%E5%BC%95%E7%94%A8"><span class="post-toc-text">10.让 operator&#x3D;返回一个自身引用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-%E5%A4%84%E7%90%86%E8%87%AA%E8%B5%8B%E5%80%BC%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">11.处理自赋值的赋值运算符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E6%AF%8F%E4%B8%80%E4%B8%AA%E9%83%A8%E5%88%86"><span class="post-toc-text">12.复制对象时勿忘每一个部分</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#13-%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="post-toc-text">13.用对象管理资源</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#14-RAII-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E8%A1%8C%E4%B8%BA"><span class="post-toc-text">14.RAII 对象的拷贝行为</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#15-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="post-toc-text">15.资源管理类中提供对原始资源的访问</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#16-new-%E5%92%8C-delete-%E5%AF%B9%E5%BA%94%E8%B5%B7%E6%9D%A5"><span class="post-toc-text">16.new 和 delete 对应起来</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#17-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%B0%86-newed-%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="post-toc-text">17.以独立的语句将 newed 对象置入智能指针</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#18-%E8%AE%A9%E6%8E%A5%E5%8F%A3%E6%9B%B4%E5%AE%B9%E6%98%93%E7%9A%84%E8%A2%AB%E4%BD%BF%E7%94%A8-%E4%B8%8D%E5%AE%B9%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="post-toc-text">18.让接口更容易的被使用,不容易被误用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#19-%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%95%88%E7%9A%84-class"><span class="post-toc-text">19.设计高效的 class</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#20-const-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E4%BC%98%E4%BA%8E%E5%80%BC%E4%BC%A0%E9%80%92"><span class="post-toc-text">20.const 引用传递优于值传递</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#21-%E4%B8%8D%E8%A6%81%E9%94%99%E8%AF%AF%E7%9A%84%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="post-toc-text">21.不要错误的返回对象的引用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#22-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E-private"><span class="post-toc-text">22.成员变量声明 private</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#23-%E9%9D%9E%E6%88%90%E5%91%98%E5%8F%88%E6%8D%A2%E5%87%BD%E6%95%B0%E6%9B%BF%E6%8D%A2%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="post-toc-text">23.非成员又换函数替换成员函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#24-%E5%BD%93%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E9%83%BD%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%86%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%BA%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="post-toc-text">24.当所有参数都需要类型转换的时候，将函数定义为非成员函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#25-%E8%87%AA%E5%AE%9A%E4%B9%89-swap-%E5%87%BD%E6%95%B0"><span class="post-toc-text">25.自定义 swap 函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#26-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="post-toc-text">26.尽可能延后变量的定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#27-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="post-toc-text">27.正确使用类型转换</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#28-%E6%B3%A8%E6%84%8F%E4%BB%A5%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98"><span class="post-toc-text">28.注意以引用方式返回对象的成员</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#29-%E5%86%99%E5%87%BA%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="post-toc-text">29.写出异常安全的代码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#30-%E7%90%86%E8%A7%A3-inline"><span class="post-toc-text">30.理解 inline</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#31-%E6%9C%80%E5%B0%8F%E5%8C%96%E6%96%87%E4%BB%B6%E4%BE%9D%E8%B5%96"><span class="post-toc-text">31.最小化文件依赖</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#32-%E7%A1%AE%E5%AE%9A-public-%E7%BB%A7%E6%89%BF%E5%BB%BA%E6%A8%A1%E5%87%BA-is-a-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="post-toc-text">32.确定 public 继承建模出 is-a 的关系</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#33-%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="post-toc-text">33.避免遮掩继承而来的名称</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#34-%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="post-toc-text">34.区分接口继承和实现继承</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#35-%E8%80%83%E8%99%91%E8%99%9A%E5%87%BD%E6%95%B0%E4%B9%8B%E5%A4%96%E5%85%B6%E4%BB%96%E7%9A%84%E9%80%89%E6%8B%A9"><span class="post-toc-text">35.考虑虚函数之外其他的选择</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#36-%E7%BB%9D%E4%B8%8D%E9%87%8D%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E6%9D%A5%E7%9A%84%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="post-toc-text">36.绝不重定义继承来的非虚函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#37-%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><span class="post-toc-text">37.不重新定义继承来的缺省参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#38-%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E5%BB%BA%E6%A8%A1%E5%87%BA-has-a-%E6%88%96%E8%80%85%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="post-toc-text">38.通过组合建模出 has-a 或者实现关系</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#39-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8-private-%E7%BB%A7%E6%89%BF"><span class="post-toc-text">39.明智而审慎地使用 private 继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#EBO%EF%BC%9A%E7%A9%BA%E5%9F%BA%E7%B1%BB%E4%BC%98%E5%8C%96"><span class="post-toc-text">EBO：空基类优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#40-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="post-toc-text">40.谨慎使用多重继承</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#41-%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81"><span class="post-toc-text">41.了解隐式接口和编译时多态</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#42-typename-%E5%8F%8C%E9%87%8D%E5%90%AB%E4%B9%89"><span class="post-toc-text">42.typename 双重含义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#43-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%B1%BB%E9%87%8C%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="post-toc-text">43.如何访问模板基类里的名称</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#44-%E6%8A%8A%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB"><span class="post-toc-text">44.把与参数无关的代码抽离</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#45-%E8%BF%90%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8E%A5%E6%94%B6%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">45.运用模板成员函数接收所有兼容类型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#46-%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8E%BB%E5%AE%9E%E7%8E%B0%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="post-toc-text">46.使用类模板的非成员函数去实现隐式类型的转换</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#47-%E4%BD%BF%E7%94%A8-traits-classes-%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="post-toc-text">47.使用 traits classes 获取类型信息</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#48-%E8%AE%A4%E8%AF%86%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B"><span class="post-toc-text">48.认识模板元编程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#49-%E8%AE%A4%E8%AF%86-new-handler"><span class="post-toc-text">49.认识 new_handler</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#50-%E4%BD%95%E6%97%B6%E6%9B%BF%E6%8D%A2-new-%E5%92%8C-delete-%E6%98%AF%E5%90%88%E7%90%86%E7%9A%84"><span class="post-toc-text">50.何时替换 new 和 delete 是合理的</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#51-%E7%BC%96%E5%86%99-new-%E5%92%8C-delete-%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="post-toc-text">51.编写 new 和 delete 时需固守常规</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#53-%E5%86%99%E4%BA%86-placement-new-%E4%B9%9F%E8%A6%81%E5%86%99-placement-delete"><span class="post-toc-text">53.写了 placement new 也要写 placement delete</span></a></li></ol>
            
        
        <div class=".article-gallery"><h2 id="2-尽量不使用-define"><a href="#2-尽量不使用-define" class="headerlink" title="2.尽量不使用#define"></a>2.尽量不使用#define</h2><p><strong>使用 const，enum 去替换宏常量，使用 inline 去替换宏函数</strong></p>
<p>#define 它是在预处理器执行的，不属于语言的一部分，而 const 、enum、inline 是在编译的时候执行的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 16.23</span></span><br></pre></td></tr></table></figure>

<p>因为 define 是在预处理时期，NUM 这个记号不会被编译器看见，因为不在编译时期处理，所以不会进到符号表里面，这个 NUM 记号会被直接用 16.23 去替换，如果把 define 写到头文件，后面调试代码的时候，或者代码有问题报错的话，这个 NUM 记号因为没有在符号表里面，所以不会有提示，我们看到的就直接是 16.23，就会很懵逼</p>
<p><strong>建议：用 const 去定义常量，定义常量字符串的话用 const * const 去保证他指针不可变，指针指向的值不可变</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> NUM = <span class="number">16.23</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> str = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line"><span class="comment">//等于</span></span><br><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">str</span><span class="params">(<span class="string">&quot;nihao&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>static const 有两种用法，一种是作为预编译声明，一种是作为类的静态常量属性。</strong></p>
<p><strong>当作为预编译声明时，static const 属性必须在声明时即指定值，而且类型仅限基本数据类型。</strong></p>
<p><strong>就像下面例子一样。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> arr[a];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相当于#define a 1 宏定义了一个宏变量 a**。编译器在编译期间就直接进行了值替换。也因为这个原因不可以对其进行取地址操作，因为他根本没有地址。**</p>
<p><strong>static 常量声明，编译器编译的时候会直接 做常量的替换</strong></p>
<p>如果后面有对他取地址，引用之类的话，编译会报错，，因为 static 修饰他等于只声明了，所以不会分配内存，因此链接的时候就会报错（重复上面的结论了）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> arr[a]; <span class="comment">//a直接用5替换</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> *p=&amp;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Text t;</span><br><span class="line">    t.<span class="built_in">fn</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就要在.cpp 写他的定义,外部去定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Text::a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Text t;</span><br><span class="line">    t.<span class="built_in">fn</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了用 static const，我们还可以用 enum 去声明一个无名的枚举，去达到<strong>预编译声明</strong>这种作用，做编译时的替换，编译时要知道数组的大小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;a=<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr[a];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>**static const 还有另一种用法是：static const 作为类的静态常量属性，**此时，不能在类的声明处进行初始化。而需要通过 类外的初始化赋值。</p>
<p>static const 常量存在于内存的常量区，有操作系统加载程序时，加载到内存的常量区。所以可以对其取址，但是不能对该区的内存进行写操作，因为这个区从操作系统级进行了只读限定，任何对该内存区的写操作会导致程序崩溃。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Text::a=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Text t;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;t.a&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>还有用 define 去定义宏函数的时候，可能有时候会有歧义</strong></p>
<p><strong>比如下面例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ADD</span>(++a,b);  -&gt;  (++a)&gt;(b) ? (++a) :(b)</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ADD</span>(++a,b<span class="number">+10</span>);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="/../img/Effecitve_C++/1698592275247-a3c837d0-cc22-4d1d-830a-1ba7dfa512ad-20251208000344995.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1698592275247-a3c837d0-cc22-4d1d-830a-1ba7dfa512ad-20251208000344995.png" alt="img"></a></p>
<p>上面的例子，当 a 大于 b 的时候，a 会加两次，而 a 小于 b 的时候，a 只会加一次，这样就会有歧义</p>
<h2 id="3-尽量用-const"><a href="#3-尽量用-const" class="headerlink" title="3.尽量用 const"></a>3.尽量用 const</h2><p><strong>使用 const 能保证一定的安全性</strong></p>
<p>STL 里面的迭代器，就是 T*类型的指针，如果我们声明迭代器是 const，比如 const auto it&#x3D;vv.begin()， 那么相当于 it 成了 T * const 类型的，（T * const it）即 it 指针不能变，，即 it++这种就不行</p>
<p>如果是用 auto it&#x3D;vv.cbegin() ，那么 it 就是 const T<em>类型的，即 it 本身是可以去修改的，但是对他解引用就不能修改，比如</em>it&#x3D;10，错误</p>
<h2 id="4-对象使用前应该被初始化"><a href="#4-对象使用前应该被初始化" class="headerlink" title="4.对象使用前应该被初始化"></a>4.对象使用前应该被初始化</h2><ol>
<li><strong>类里面成员变量的初始化顺序跟 你构造函数，初始化列表的顺序没有半毛钱关系，只跟你定义的顺序有关系</strong></li>
<li><strong>初始化列表的方式优于函数体内直接赋值</strong></li>
</ol>
<p><strong>函数体内赋值的话-》 构造，构造，拷贝赋值</strong></p>
<p><strong>初始化列表-》 构造 ，拷贝构造</strong></p>
<p>有的变量必须要在初始化列表中进行，比如引用类型，const 类型，因为在构造函数体内的是赋值，因为这些变量不可以被赋值.</p>
<p><strong>还有个问题：c++中跨编译单元的对象初始化的顺序是不定的</strong></p>
<p><strong>所以有如下问题，且条款给了解决办法</strong></p>
<p><strong>首先解释两个概念：</strong></p>
<p>1.编译单元：简单的说，按照 C++标准，每一个.cpp 文件就是一个编译单元，编译器不会编译.h 头文件。</p>
<p>2.static 对象：特点：生命周期从创建一直到程序结束为止。包括：全局(global)对象；定义域命名空间(namespace)作用域内的对象；在 class 内、函数内以及 file 作用域内被声明为 static 的对象。</p>
<p>函数内的 static 对象就叫做：local static 对象。除此之外的 static 对象就是所谓的 non-local static 对象。</p>
<p>标题的意思，解释下来，就是在两份.cpp 源码中，分别包含有一个 non-local static 对象，恰好这两个对象要初始化的时候又与另外一个有所关联，这时候就会存在一个初始化次序问题。举个例子就是，源码 1 中定义了 nls（non-local static）对象 A，源码 2 中定义了 nls 对象 B，当 B 要初始化的时候会用到 A 的成员，如果在 B 要初始化的时候 A 还没有初始化，就会报错了。而 C++中对于不同源码中的 nls 对象的初始化次序问题没有明确定义，也就是 A 和 B 初始化谁先谁后根本就是无解的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">fun</span><span class="params">()</span><span class="type">const</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> A aa;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(param)&#123;</span><br><span class="line">        std::<span class="type">size_t</span> num=aa.<span class="built_in">fun</span>();<span class="comment">//用A的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---main---</span><br><span class="line"><span class="comment">//构造B 有问题,B不知道A有没有构造好，就直接用人家的成员了</span></span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>除非 A 在 B 之前先被初始化，否则 B 的构造函数会用到还未初始化的 A，但上文已经提到相关的初始化次序是一个无解的问题。</p>
<p>条款的解决办法：把每个类的 non-local static 对象，搬到类专属的函数里面，写成 local static，然后返回他的引用。。就跟单例的写法一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">fun</span><span class="params">()</span><span class="type">const</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A&amp; <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> A aa;</span><br><span class="line">    <span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(param)&#123;</span><br><span class="line">        std::<span class="type">size_t</span> num=<span class="built_in">instance</span>().<span class="built_in">fun</span>();<span class="comment">//用A的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">B&amp; <span class="title">pp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> B bb;</span><br><span class="line">    <span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照 C++的标准，函数内的 local static 对象会在该函数被调用期间首次遇到该对象的定义式时被初始化，也就是调用函数 instance 时 A 对象将已经完成初始化，即解决了本文所述的次序问题。同时如果从未调用此函数，也绝不会产生构造和析构成本，非常划算。</p>
<h2 id="5-了解-C-默认生成的函数"><a href="#5-了解-C-默认生成的函数" class="headerlink" title="5.了解 C++默认生成的函数"></a>5.了解 C++默认生成的函数</h2><p>构造函数，析构函数，拷贝构造，拷贝赋值，C++11 之后的移动构造和移动赋值</p>
<p>如果我们写了其中一个，那么别的都不会给我们默认生成了，需要我们自己去写</p>
<p><strong>如果写了拷贝构造，他还是会自动给我们生成拷贝赋值（98&#x2F;11 之后，，这是历史原因，是为了兼容老代码，不过按理不应该给我们去生成）</strong></p>
<p>一旦写了移动构造&#x2F;赋值，其中任意一个，另一个移动的函数就不会给我们默认生成，且拷贝的函数（拷贝构造&#x2F;赋值）也不会给我们生成</p>
<p><strong>定义了析构，拷贝构造&#x2F;赋值还是会给我们生成的（还是历史原因），但是移动之类的不会被生成（这块有个性能问题，所以写了析构，别的怎么都要自己定义一下，哪怕用 default 默认的）</strong></p>
<p><strong>总结：只要写一个其他都写</strong></p>
<p><strong>注意：引用成员数据导致不能拷贝赋值，是因为引用一旦初始化就不能更改绑定对象，而拷贝赋值则要求更改绑定对象，冲突了</strong></p>
<h2 id="6-不想使用特种函数，就要明确拒绝"><a href="#6-不想使用特种函数，就要明确拒绝" class="headerlink" title="6.不想使用特种函数，就要明确拒绝"></a>6.不想使用特种函数，就要明确拒绝</h2><p>C++11 提供了 delete 关键字，我们可以直接删除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Home</span>(<span class="type">const</span> Home&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    Home&amp;<span class="keyword">operator</span> =(<span class="type">const</span> Home&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>C++98 怎么做的呢？</strong></p>
<p><strong>写一个禁止拷贝的类，然后放成私有的，子类去继承他，这样子类的拷贝就无法生效</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:  <span class="comment">//允许子类去构造和析构</span></span><br><span class="line">    <span class="built_in">Uncopy</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Uncopy</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopy</span>(<span class="type">const</span> Uncopy&amp;);  <span class="comment">//只声明不能去定义</span></span><br><span class="line">    Uncopy&amp;<span class="keyword">operator</span> =(<span class="type">const</span> Uncopy&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span>:<span class="keyword">public</span> Uncopy</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-给多态基类的析构声明-virtual"><a href="#7-给多态基类的析构声明-virtual" class="headerlink" title="7.给多态基类的析构声明 virtual"></a>7.给多态基类的析构声明 virtual</h2><p>要表现多态的行为，父类指针&#x2F;引用指向派生类对象，防止内存泄漏，子类的对象没法去析构，所以父类析构要去写成虚的</p>
<h2 id="8-析构函数不要抛异常"><a href="#8-析构函数不要抛异常" class="headerlink" title="8.析构函数不要抛异常"></a>8.析构函数不要抛异常</h2><p>c++11 之后析构抛出异常就是一个未定义行为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Widget</span>()&#123;&#125; <span class="comment">//析构可能会有异常</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Widget&gt;vv;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当vv出作用域要析构</span></span><br></pre></td></tr></table></figure>

<p>vv 析构的时候肯定要去析构他里面的一个个 widget 元素，如果其中某个 widget 的析构抛出了异常，那么可能会直接退出程序，或者产生未定义行为，这样都会导致内存泄漏，后续的 widget 无法处理</p>
<p><strong>然而如果你的析构必须要执行一些操作，然而这些操作可能会抛出异常，那么该怎么办？</strong></p>
<p>两个简单的操作就是执行对应析构处直接 try 捕获，如果有异常直接 abort 退出，或者吞下这个异常，不做处理。但是这两种方法都不好，因为对外提供的话，并没有给客户提供一个如果产生异常了，客户那边的代码可以做什么处理的机会。因为客户没法去操作程序已经写死的析构了</p>
<p><strong>那么最好的方法就是给客户提供这么一个自己去处理异常的机会，怎么做？看下面示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DbConnection</span> <span class="comment">//负责数据库连接</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> DbConnection <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回一个DbConnection对象</span></span><br><span class="line">        <span class="type">static</span> DbConnection res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//做关闭连接，如果失败则抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DbConn</span>&#123; <span class="comment">//管理DbConnection对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;  <span class="comment">//给客户使用的新函数</span></span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        ifclosed=<span class="literal">true</span>; <span class="comment">//走到这说明close没问题，DbConn的析构异常处理也不会走</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">DbConn</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ifclosed)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;       <span class="comment">//关闭连接</span></span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">                <span class="comment">//如果关闭失败</span></span><br><span class="line">                <span class="comment">//记录下来，结束程序</span></span><br><span class="line">                <span class="comment">//或者吞下异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DbConnection db;</span><br><span class="line">    <span class="type">bool</span> ifclosed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样做的话，客户用到 DbConn 的 close，如果里面调用的 DbConnection 的 close 抛出了异常，走到 DbConn 的析构，这样客户在外部可以去做对应的异常处理</p>
<p><a href="/../img/Effecitve_C++/1699538322637-587fc78e-f47f-4f68-9802-40cf1400968f-20251208000345423.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699538322637-587fc78e-f47f-4f68-9802-40cf1400968f-20251208000345423.png" alt="img"></a></p>
<h2 id="9-不要在构造和析构里面调用-virtual-函数"><a href="#9-不要在构造和析构里面调用-virtual-函数" class="headerlink" title="9.不要在构造和析构里面调用 virtual 函数"></a>9.不要在构造和析构里面调用 virtual 函数</h2><p>在构造里面用虚函数，子类还没有创建，你如果想要去用到多态，调用到子类的虚函数，其实是一个未定义的行为，构造里面还是静态绑定，也就只能调用他本身的那个虚函数</p>
<p><a href="/../img/Effecitve_C++/1699539325532-9d3d7306-70c7-43dd-a21b-360f03da1219-20251208000348368.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699539325532-9d3d7306-70c7-43dd-a21b-360f03da1219-20251208000348368.png" alt="img"></a></p>
<p>析构的时候，子类已经析构了，父类里面调用虚函数的话，肯定就调用不到子类的虚函数了，也只能调到父类他本身的</p>
<p><a href="/../img/Effecitve_C++/1699539422106-03306e1f-bef5-4f2d-b69b-b7e60cb7b375-20251208000344830.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699539422106-03306e1f-bef5-4f2d-b69b-b7e60cb7b375-20251208000344830.png" alt="img"></a></p>
<p>本质就是在 Dervie 对象的 Base 构造期间，对象的类型是 Base，析构同理，Dervie 对象的 Base 析构期间，对象是 Base</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base hello&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bye</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base bye&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>()&#123;</span><br><span class="line">        <span class="comment">//调用虚函数</span></span><br><span class="line">        <span class="comment">//如果想要看到多态的效果，就是说调用到子类的虚函数，那是不行的</span></span><br><span class="line">        <span class="built_in">hello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用虚函数</span></span><br><span class="line">        <span class="comment">//如果想要看到多态的效果，就是说调用到子类的虚函数，那是不行的</span></span><br><span class="line">        <span class="built_in">bye</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dervie</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Dervie hello&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bye</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Dervie bye&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dervie</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dervie *bs=<span class="keyword">new</span> <span class="built_in">Dervie</span>();</span><br><span class="line">    <span class="keyword">delete</span>  bs;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按理说对象是 Dervie 应该打印的是 Dervice 的虚函数，实则不是的，因为走到构造析构里面都实行静态绑定了，所以打印的都是 Base</p>
<p><a href="/../img/Effecitve_C++/1699539273931-473537fa-2345-42f2-8175-4a194bee12e9-20251208000345205.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699539273931-473537fa-2345-42f2-8175-4a194bee12e9-20251208000345205.png" alt="img"></a></p>
<h2 id="10-让-operator-返回一个自身引用"><a href="#10-让-operator-返回一个自身引用" class="headerlink" title="10.让 operator&#x3D;返回一个自身引用"></a>10.让 operator&#x3D;返回一个自身引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要是为了支持连&#x3D;的这种操作： m&#x3D;n&#x3D;y&#x3D;5;</p>
<h2 id="11-处理自赋值的赋值运算符"><a href="#11-处理自赋值的赋值运算符" class="headerlink" title="11.处理自赋值的赋值运算符"></a>11.处理自赋值的赋值运算符</h2><p>也就是说写 operator&#x3D;的时候刚开始要做自我判等</p>
<p>然后对于数据可能抛出异常的部分，我们可以保存一下源数据，防止在赋值之前，先删了源数据</p>
<p>如果赋值没问题，再删源数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==other)&#123;  <span class="comment">//自我判等</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>*tmp=p;<span class="comment">//用个临时变量 保存原始数据</span></span><br><span class="line">        p=<span class="keyword">new</span> <span class="built_in">Widget</span>(*other.p); <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">delete</span> tmp; <span class="comment">//删除</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>*p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="12-复制对象时勿忘每一个部分"><a href="#12-复制对象时勿忘每一个部分" class="headerlink" title="12.复制对象时勿忘每一个部分"></a>12.复制对象时勿忘每一个部分</h2><p>在写派生类的构造，拷贝构造，赋值，移动等等函数过程中，<strong>不要忘了时刻对于父类的成员也要做小心的复制</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Base</span><span class="params">(string name=<span class="string">&quot;unKnow&quot;</span>)</span>:m_name(move(name))&#123;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base().name=&quot;</span>&lt;&lt;m_name&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp;other)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base(const Base&amp;other).name=&quot;</span>&lt;&lt;m_name&lt;&lt;endl;</span><br><span class="line">        m_name=other.m_name;</span><br><span class="line">    &#125;</span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base&amp; operator=(const Base&amp;other).name=&quot;</span>&lt;&lt;m_name&lt;&lt;endl;</span><br><span class="line">        m_name=other.m_name;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dervie</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp;<span class="keyword">operator</span> &lt;&lt;(ostream&amp;os,<span class="type">const</span> Dervie&amp;des);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Dervie</span>(string name,<span class="type">int</span> id):<span class="built_in">Base</span>(name),<span class="built_in">m_id</span>(id)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Dervie(string name,int id):&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m_id&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dervie</span>(<span class="type">const</span> Dervie&amp;other):<span class="built_in">Base</span>(other)</span><br><span class="line">    &#123;</span><br><span class="line">        m_id=other.m_id;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Dervie(const Dervie&amp;other):&quot;</span>&lt;&lt;*<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Dervie&amp;<span class="keyword">operator</span>=(<span class="type">const</span> Dervie&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        Base::<span class="keyword">operator</span>=(other);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;other)&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_id=other.m_id;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Dervie&amp;operator=(const Dervie&amp;other):&quot;</span>&lt;&lt;*<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp;<span class="keyword">operator</span> &lt;&lt;(ostream&amp;os,<span class="type">const</span> Dervie&amp;des)</span><br><span class="line">&#123;</span><br><span class="line">  os&lt;&lt;des.m_name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;des.m_id&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Dervie <span class="title">d1</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">45</span>)</span></span>;</span><br><span class="line">    <span class="comment">//copy</span></span><br><span class="line">    <span class="function">Dervie <span class="title">d2</span><span class="params">(d1)</span></span>;</span><br><span class="line">    <span class="comment">//=</span></span><br><span class="line">    <span class="function">Dervie <span class="title">d3</span><span class="params">(<span class="string">&quot;nini&quot;</span>,<span class="number">11</span>)</span></span>;</span><br><span class="line">    d3=d2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在这里：因为 Base 里面有成员，Dervie 继承之后，肯定也要对继承来的 Base 成员做初始化&#x2F;赋值</p>
<p><a href="/../img/Effecitve_C++/1699609337881-cdbc758d-49cc-43b0-890d-a4f32d4c6573-20251208000345395.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699609337881-cdbc758d-49cc-43b0-890d-a4f32d4c6573-20251208000345395.png" alt="img"></a></p>
<h2 id="13-用对象管理资源"><a href="#13-用对象管理资源" class="headerlink" title="13.用对象管理资源"></a>13.用对象管理资源</h2><p>用智能指针，RAII，栈上对象出作用域自动析构</p>
<h2 id="14-RAII-对象的拷贝行为"><a href="#14-RAII-对象的拷贝行为" class="headerlink" title="14.RAII 对象的拷贝行为"></a>14.RAII 对象的拷贝行为</h2><p>lock_guard 不具有拷贝和移动的行为</p>
<p>unique_ptr 禁止拷贝，可以移动</p>
<p>shared_ptr 拷贝 引用计数+1</p>
<p>string 拷贝底层资源，深拷贝</p>
<h2 id="15-资源管理类中提供对原始资源的访问"><a href="#15-资源管理类中提供对原始资源的访问" class="headerlink" title="15.资源管理类中提供对原始资源的访问"></a>15.资源管理类中提供对原始资源的访问</h2><p>比如智能指针都提供 get 方法能获取原始指针</p>
<p>所以我们自己写 RAII 这种类的时候，也要提供这种方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FontEvent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Font f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">FontEvent</span><span class="params">(Font fg)</span>:f(fg)&#123;</span>&#125;</span><br><span class="line">	~<span class="built_in">FontEvent</span>()&#123;<span class="built_in">relseseFont</span>(f);&#125;</span><br><span class="line">	<span class="comment">//get</span></span><br><span class="line">	<span class="function">Font <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> f;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="16-new-和-delete-对应起来"><a href="#16-new-和-delete-对应起来" class="headerlink" title="16.new 和 delete 对应起来"></a>16.new 和 delete 对应起来</h2><p><a href="/../img/Effecitve_C++/1699613989633-5cebde68-faf4-46ee-96eb-c234f2273c7a-20251208000345485.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699613989633-5cebde68-faf4-46ee-96eb-c234f2273c7a-20251208000345485.png" alt="img"></a></p>
<h2 id="17-以独立的语句将-newed-对象置入智能指针"><a href="#17-以独立的语句将-newed-对象置入智能指针" class="headerlink" title="17.以独立的语句将 newed 对象置入智能指针"></a>17.以独立的语句将 newed 对象置入智能指针</h2><p>这么一段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;Widget&gt; pw,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们这样去传</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget),priority())</span></span></span><br></pre></td></tr></table></figure>

<p>由于不同的编译器，priority()，new Widget，shared_ptr，他们三个执行的顺序可能不一样，如果说 new Widget 先执行，priority()再执行，而 priority()抛异常了，那么 new Widget 就会内存泄漏</p>
<p><strong>书中建议：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Widget&gt;<span class="built_in">pw</span>(<span class="keyword">new</span> Widget);  <span class="comment">//先把对象构建出来</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(pw,priority())</span>  <span class="comment">//即使priority()抛出异常了，但是跟Widget内存泄漏也没关系</span></span></span><br></pre></td></tr></table></figure>

<p><strong>但是现在关于智能指针的创建都建议用 make_shared 这种</strong></p>
<h2 id="18-让接口更容易的被使用-不容易被误用"><a href="#18-让接口更容易的被使用-不容易被误用" class="headerlink" title="18.让接口更容易的被使用,不容易被误用"></a>18.让接口更容易的被使用,不容易被误用</h2><p>写个日期类,注意我们要在 Month 里面对传入的数字做判断和处理，其次这种需要用户手动去构造传的方式有很多未知性，所以不好</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Month</span>(<span class="type">int</span> mon):<span class="built_in">m_mon</span>(mon);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_mon;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Date</span>(<span class="built_in">Month</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><strong>可以这么去设计：我们去提供写死的静态函数，让用户去用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">One</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Two</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">2</span>);&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Three</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">3</span>);&#125;</span><br><span class="line">   <span class="comment">// ..</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Month</span>(<span class="type">int</span> mon):<span class="built_in">m_mon</span>(mon);</span><br><span class="line">    <span class="type">int</span> m_mon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>(Month::<span class="built_in">One</span>());</span><br></pre></td></tr></table></figure>

<p>还有用 const 去修饰 operator 一些重载函数，去避免错误</p>
<p>再就是用智能指针</p>
<h2 id="19-设计高效的-class"><a href="#19-设计高效的-class" class="headerlink" title="19.设计高效的 class"></a>19.设计高效的 class</h2><p><a href="/../img/Effecitve_C++/1699682253611-67959e8b-12c5-4f88-a4a9-9f1e02f4aff6-20251208000345401.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699682253611-67959e8b-12c5-4f88-a4a9-9f1e02f4aff6-20251208000345401.png" alt="img"></a><a href="/../img/Effecitve_C++/1699682273327-055c651d-1d82-4c71-b1c0-18fed9533ab5-20251208000346651.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699682273327-055c651d-1d82-4c71-b1c0-18fed9533ab5-20251208000346651.png" alt="img"></a><a href="/../img/Effecitve_C++/1699682286020-76eebcd6-8090-426e-99f1-aaa4f3758ade-20251208000345691.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699682286020-76eebcd6-8090-426e-99f1-aaa4f3758ade-20251208000345691.png" alt="img"></a></p>
<h2 id="20-const-引用传递优于值传递"><a href="#20-const-引用传递优于值传递" class="headerlink" title="20.const 引用传递优于值传递"></a>20.const 引用传递优于值传递</h2><p>减少开销</p>
<p>引用传参可以避免对象切割，能去表现多态的行为</p>
<p>一般建议，内置类型，STL 迭代器，函数对象用值传递，其他尽量用引用</p>
<h2 id="21-不要错误的返回对象的引用"><a href="#21-不要错误的返回对象的引用" class="headerlink" title="21.不要错误的返回对象的引用"></a>21.不要错误的返回对象的引用</h2><p>不要返回局部变量的引用</p>
<p>局部非静态的栈对象，出作用域析构，如果返回引用，这块内存已经析构，这就是未定义行为。</p>
<p>局部静态的栈对象，静态就是只有一份，各个都会去修改这个静态变量，操作的都是同一份</p>
<p>局部堆上的对象，会产生中间结果，中间结果没法 delete，就有内存泄漏</p>
<h2 id="22-成员变量声明-private"><a href="#22-成员变量声明-private" class="headerlink" title="22.成员变量声明 private"></a>22.成员变量声明 private</h2><p>成员隐藏起来，对外提供接口访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessAble</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getid</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_id;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="23-非成员又换函数替换成员函数"><a href="#23-非成员又换函数替换成员函数" class="headerlink" title="23.非成员又换函数替换成员函数"></a>23.非成员又换函数替换成员函数</h2><p>将不同的功能函数放在不同的头文件，但是都隶属于同一个命名空间</p>
<p>有点类似&lt;C++StandarLibrary&gt;里面包含的 std 空间的每个东西</p>
<p>我们相用 vector，就引入 vector 头文件就行，但是 vector 其实是在 std 作用域下的</p>
<p>相用 list，就引入 list 头文件就行</p>
<p><a href="/../img/Effecitve_C++/1699690409456-1fed0eaf-f29b-4056-8167-0bd1128ed2b1-20251208000345665.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699690409456-1fed0eaf-f29b-4056-8167-0bd1128ed2b1-20251208000345665.png" alt="img"></a></p>
<h2 id="24-当所有参数都需要类型转换的时候，将函数定义为非成员函数"><a href="#24-当所有参数都需要类型转换的时候，将函数定义为非成员函数" class="headerlink" title="24.当所有参数都需要类型转换的时候，将函数定义为非成员函数"></a>24.当所有参数都需要类型转换的时候，将函数定义为非成员函数</h2><p>有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ration</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Ration</span>(<span class="type">int</span> n = <span class="number">0</span>, <span class="type">int</span> d = <span class="number">1</span>) : <span class="built_in">numer</span>(n), <span class="built_in">denom</span>(d) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getnumer</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> numer; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdenom</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> denom; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Ration <span class="keyword">operator</span>*(<span class="type">const</span> Ration &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;numer * other.numer, denom * other.denom&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numer;</span><br><span class="line">    <span class="type">int</span> denom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Ration <span class="title">r1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Ration <span class="title">r2</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    Ration rr = r1 * r2; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    Ration res;</span><br><span class="line">    res = r1 * <span class="number">2</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    res = <span class="number">2</span> * r2; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重载了<em>号，但是 2</em>r1 错误，这是为什么呢？ 按理说我们要重载*号，之后这么写应该是可以的</p>
<p><strong>我们先分析一下代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = r1 * <span class="number">2</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>等于</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res= r<span class="number">1.</span><span class="keyword">operator</span>*(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>而 Ration 的构造函数我没有加 explict，说明可以隐式转换，因此</p>
<p>传入的 2，直接给到了构造函数，相当于构造了临时对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Ration <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">res=r1 * temp;</span><br><span class="line">也就是</span><br><span class="line">r<span class="number">1.</span>opertor*(temp)</span><br></pre></td></tr></table></figure>

<p>按照上面的逻辑，res&#x3D;2 * r1;肯定就有问题了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">他其实就是</span><br><span class="line">res= <span class="number">2.</span><span class="keyword">operator</span>*(r1);</span><br></pre></td></tr></table></figure>

<p>这么写他会报错，：error: no match for ‘operator*‘ (operand types are ‘int’ and ‘Ration’)</p>
<p>编译器会找一个 第一个参数是 int，第二个参数是 Ration 的重载*，但是没有</p>
<p>operator*写到成员函数里面，相当于第一个参数就是 Ration 对象</p>
<p><strong>所以要把 operator 重载写成一个非成员函数,接收两个参数，都是 Ration 类型，因为 Ratio 构造运行隐式转换，因此对于上面所有情况都是符合的</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Ration <span class="keyword">operator</span>*(<span class="type">const</span> Ration &amp;one,<span class="type">const</span> Ration &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;one.<span class="built_in">getnumer</span>() * other.<span class="built_in">getnumer</span>(), one.<span class="built_in">getdenom</span>() * other.<span class="built_in">getdenom</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-自定义-swap-函数"><a href="#25-自定义-swap-函数" class="headerlink" title="25.自定义 swap 函数"></a>25.自定义 swap 函数</h2><p>C++11 之后采用移动 move，可以规避示例很多问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassText</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string *str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(ClassText&amp; a,ClassText&amp; b)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(ClassText&amp; t)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;str,t.str);  <span class="comment">//交换指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(ClassText&amp; a,ClassText&amp; b)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ClassText <span class="title">a</span><span class="params">(<span class="string">&quot;xxx&quot;</span>)</span></span>;</span><br><span class="line">    ClassText b;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;*(a.str)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*(b.str)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用到 void swap(ClassText&amp; a,ClassText&amp; b)，里面调用到 a.swap(b);然后进入 ClassText 调用到 void swap(ClassText&amp; t) noexcept，里面再调用 std 的 swap</p>
<h2 id="26-尽可能延后变量的定义"><a href="#26-尽可能延后变量的定义" class="headerlink" title="26.尽可能延后变量的定义"></a>26.尽可能延后变量的定义</h2><p>要用到的时候再定义变量</p>
<p><a href="/../img/Effecitve_C++/1699852082095-e64c4250-0a61-4e0f-a8d1-43780f62aaed-20251208000345559.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699852082095-e64c4250-0a61-4e0f-a8d1-43780f62aaed-20251208000345559.png" alt="img"></a><a href="/../img/Effecitve_C++/1699852373124-729078ef-823c-45ea-b8a5-a80273cced8c-20251208000346155.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699852373124-729078ef-823c-45ea-b8a5-a80273cced8c-20251208000346155.png" alt="img"></a></p>
<h2 id="27-正确使用类型转换"><a href="#27-正确使用类型转换" class="headerlink" title="27.正确使用类型转换"></a>27.正确使用类型转换</h2><p>static_cast 如果存在表达式到新类型的隐式转换，或者如果针对以<em>表达式</em> 对<em>新类型</em> 类型的对象或引用所进行的<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/direct_initialization">直接初始化</a>的重载决议找到至少一个可行函数，<strong>那么</strong> <strong>static_cast**</strong>&lt;<strong>*<strong>新类型**</strong>*&gt;(***<strong>表达式**</strong>*) 返回如同以</strong> <strong>*新类型*</strong> <strong>Temp(***<strong>表达式**</strong>*)，也就是说返回一个临时变量</strong></p>
<p>简单地说 static_cast 用于真正的类型变换 也就是类型之间不存在层级关系 而是通过自定义转换函数或转换构造函数进行转换 对于存在层级关系的转换 都应该用 dynamic_cast</p>
<h2 id="28-注意以引用方式返回对象的成员"><a href="#28-注意以引用方式返回对象的成员" class="headerlink" title="28.注意以引用方式返回对象的成员"></a>28.注意以引用方式返回对象的成员</h2><p>返回引用可不是个好习惯，要是返回类型很大，用智能指针代替</p>
<h2 id="29-写出异常安全的代码"><a href="#29-写出异常安全的代码" class="headerlink" title="29.写出异常安全的代码"></a>29.写出异常安全的代码</h2><p>pimpl 设计方式：用一个私有的指针去指向隐藏的具体实现的类</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xhtchina/article/details/112795569">https://blog.csdn.net/xhtchina/article/details/112795569</a></p>
<p>实现异常安全的策略：常用 copy and swap 的经典方法：为打算修改的对象作出副本，然后操作副本，最后 swap（不抛出异常）交换当前对象和副本，这样因为 swap 不抛出异常，即使之前的部分有抛出异常，但是因为操作副本，所以对于本对象没有什么影响</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pimpl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> img;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Menu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Pimpl&gt; <span class="title">get_mptr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Pimpl&gt; m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line">mutex m_tx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">mx</span><span class="params">(m_tx)</span></span>;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    Menu menu;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Pimpl&gt; <span class="title">temp</span><span class="params">(<span class="keyword">new</span> Pimpl(*(menu.get_mptr())))</span></span>;</span><br><span class="line">    temp-&gt;img++;</span><br><span class="line">	<span class="comment">//上面都是对temp操作的</span></span><br><span class="line">    <span class="built_in">swap</span>(menu.<span class="built_in">get_mptr</span>(), temp); <span class="comment">// 交换 异常安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="30-理解-inline"><a href="#30-理解-inline" class="headerlink" title="30.理解 inline"></a>30.理解 inline</h2><p>现在编译器 想要 inline，基本不参考我们写的 inline 关键字了</p>
<ul>
<li><strong>inline 允许函数定义出现在多个编译单元</strong></li>
</ul>
<p>这个性质用来在头文件中定义函数，再通过#include 拷贝到各个源文件中。<strong>如果要在头文件中定义函数，则函数必须标记为**<strong>inline*</strong>*（显式或隐式）</strong>。否则只要#include 该头文件超过一次，编译器就会报错（重复定义）。</p>
<p>inline 标记的函数，符号会记录成 weak，链接器会允许 weak 的符号存在多个，链接的时候任取一个<a href="/../img/Effecitve_C++/1699880723421-2f5b70f6-5f80-4bdb-9405-33116c2bd27c-20251208000345976.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699880723421-2f5b70f6-5f80-4bdb-9405-33116c2bd27c-20251208000345976.png" alt="img"></a><a href="/../img/Effecitve_C++/1699880737962-046171ea-0733-4bce-b504-3b90bb874ed0-20251208000345753.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699880737962-046171ea-0733-4bce-b504-3b90bb874ed0-20251208000345753.png" alt="img"></a><a href="/../img/Effecitve_C++/1699880745494-73042682-0a47-4086-a2e6-8626b1b5f2c6-20251208000345893.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699880745494-73042682-0a47-4086-a2e6-8626b1b5f2c6-20251208000345893.png" alt="img"></a><a href="/../img/Effecitve_C++/1699880753841-12a7d50a-55fa-48ff-8629-3558ff33b02f-20251208000345901.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699880753841-12a7d50a-55fa-48ff-8629-3558ff33b02f-20251208000345901.png" alt="img"></a><a href="/../img/Effecitve_C++/1699880774076-c864460e-90cf-4bc6-a2ea-4481e65c226a-20251208000346182.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1699880774076-c864460e-90cf-4bc6-a2ea-4481e65c226a-20251208000346182.png" alt="img"></a></p>
<ul>
<li><strong>C++17，可以在类内直接用 inline 去修饰静态成员，直接在类内定义，而不用再去类外初始化。同样的他修饰之后符号绑定类型是 weak</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassText</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> foo=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>inline 命名空间</strong></li>
<li><strong>类里面的成员函数在声明的时候直接定义，默认是 inline 的，隐式的一种 inline。不需要我们手动去加</strong></li>
<li><strong>模板函数，在产生符号绑定的时候都是 weak 的，所以模板才能在不同的编译单元中去引用</strong></li>
<li><strong>编译器并不真正对声明为 inline 的构造和析构函数内联，因为编译器会在构造和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等），<strong>致使构造函数&#x2F;析构函数并不像看上去的那么精简</strong>。</strong></li>
<li><strong>将虚函数声明为 inline，要分情况讨论</strong></li>
</ul>
<ol>
<li>有的人认为虚函数被声明为 inline，但是编译器并没有对其内联，他们给出的理由是 inline 是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？</li>
<li>上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数时，就内联展开。</li>
<li><strong>综上，当是指向派生类的指针调用声明为 inline 的虚函数时，不会内联展开；当是对象调用虚函数时，会内联展开。</strong></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24185638">https://www.zhihu.com/question/24185638</a></p>
<h2 id="31-最小化文件依赖"><a href="#31-最小化文件依赖" class="headerlink" title="31.最小化文件依赖"></a>31.最小化文件依赖</h2><p>构建对象需要知道内存布局，所以可以用指针去代替，因为对于指针来说，编译器只用分配 4&#x2F;8 字节固定内存就行，通过指针去访问，然后可以依赖 class 前置声明</p>
<p><strong>一般用两种设计思想：handle class 和 interface class</strong></p>
<p><strong>handle class:</strong></p>
<p><strong>把一个类变为一个接口类和实现类**</strong>，实现类就是原来这个类，接口类就是原来这个类的接口函数和一个智能指针对象指向实现类；接口类里面需要用到的类，我们提供给它的都是类的向前声明，所以为了严格执行这样的准则，我们把每一个类（包括接口类和实现类）都提供两个头文件，一个是类的声明 xxfwd.h，一个是类的定义 xx.h**</p>
<p><strong>旧的 person.h 文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name,<span class="type">const</span> Date&amp; date,<span class="type">const</span> Address&amp; address);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthdate</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    Date m_date;</span><br><span class="line">    Address m_address;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>经过 handle class 设计</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//personfwd.h   前置声明公共类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//datefwd.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">date</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//addressfwd.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//personImplfwd.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>;</span><br><span class="line"><span class="comment">//person.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;datefwd.h &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;addressfwd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;personImplfwd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name,<span class="type">const</span> Date&amp; date,<span class="type">const</span> Address&amp; address);</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthdate</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PersonImpl&gt; plml; <span class="comment">//指向具体实现类的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//personImpl.h 有着和Person完全相同的成员函数，两者接口完全相同。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>     <span class="comment">//实现类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PersonImpl</span>( <span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr );</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">birthdate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    Date m_date;</span><br><span class="line">    Address m_address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//personImpl.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;personImpl.h&quot;</span></span></span><br><span class="line"><span class="function">std::string <span class="title">PersonImpl::name</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_date;       <span class="comment">//具体实现功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 person 只需要通过指针去调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//person.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;personImpl.h&quot;</span></span></span><br><span class="line"><span class="function">std::string <span class="title">Person::name</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> plml-&gt;<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ul>
<li>成员函数必须通过 implemention pointer 取得对象数据，访问是间接的，且增加了 implemetion pointer 的指针的内存，增加了动态内存分配的管理开销，及 bad_alloc 异常的处理难度。</li>
</ul>
<p><strong>interface class</strong></p>
<p><strong>原来一个 A 类，让它的接口成为一个抽象基类 class A，具体是 接口函数都定义成为 纯虚函数, 析构函数是虚函数，还有一个 static 工厂函数 create 返回 shared_ptr<A></strong></p>
<p><strong>它的实现成为派生类 Aimpl，这样改变 A 类的实现，就改变 Aimpl 的实现就 ok 了</strong></p>
<p><strong>客户用的时候只能 shared_ptr<A> Aptr(A::create(参数) ) ; 这样用</strong></p>
<p><a href="/../img/Effecitve_C++/1700185054738-5e9c79d5-2ff0-40fc-ba61-7a0379f98873-20251208000346148.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1700185054738-5e9c79d5-2ff0-40fc-ba61-7a0379f98873-20251208000346148.png" alt="img"></a><a href="/../img/Effecitve_C++/1700185114981-d55070f7-3f66-499f-b8aa-17d92ad27ba4-20251208000346131.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1700185114981-d55070f7-3f66-499f-b8aa-17d92ad27ba4-20251208000346131.png" alt="img"></a></p>
<h2 id="32-确定-public-继承建模出-is-a-的关系"><a href="#32-确定-public-继承建模出-is-a-的关系" class="headerlink" title="32.确定 public 继承建模出 is-a 的关系"></a>32.确定 public 继承建模出 is-a 的关系</h2><p>public 继承是一个意味着 is-a，适用于 base classes 身上的每一件事件一定也适用于 derived classes 身上，因为每一个 derived classes 对象也都是一个 base classes 对象</p>
<h2 id="33-避免遮掩继承而来的名称"><a href="#33-避免遮掩继承而来的名称" class="headerlink" title="33.避免遮掩继承而来的名称"></a>33.避免遮掩继承而来的名称</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a=<span class="number">20.12</span>;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形成变量遮蔽，优先看到作用范围更小的，所以打印 20.12</p>
<p><strong>继承里面的遮蔽，可以理解为隐藏，即派生类的函数屏蔽了父类的同名函数，派生类同名的符号，会把基类里面同名的符号全部都遮蔽掉</strong></p>
<p><strong>举个例子：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Base void f1()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="comment">//重载版本</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Base void f1(int)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">double</span>)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Base void f1(double)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Base int f1(int,int)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">	<span class="comment">//void f1(int)&#123;cout&lt;&lt;&quot;errr&quot;&lt;&lt;endl;&#125;</span></span><br><span class="line">    <span class="comment">//不能同时重载一个非虚函数和一个具有相同名称和参数类型的虚函数。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Base void f2()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Base void f3()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">double</span>)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Base void f3(double)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dervice</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Dervice void f1()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Dervice void f2()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Dervice void f3()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dervice dd;</span><br><span class="line"></span><br><span class="line">    dd.<span class="built_in">f1</span>(); <span class="comment">//Dervice void f1()</span></span><br><span class="line"></span><br><span class="line">    dd.<span class="built_in">f1</span>(<span class="number">10</span>);<span class="comment">//no matching function for call to &#x27;Dervice::f1(int)&#x27;</span></span><br><span class="line">    dd.<span class="built_in">f1</span>(<span class="number">20.2</span>);<span class="comment">//no matching function for call to &#x27;Dervice::f1(double)&#x27;</span></span><br><span class="line">    dd.<span class="built_in">f1</span>(<span class="number">10</span>,<span class="number">10</span>);<span class="comment">//no matching function for call to &#x27;Dervice::f1(int, int)&#x27;</span></span><br><span class="line"></span><br><span class="line">    dd.<span class="built_in">f2</span>();<span class="comment">//Dervice void f2()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    dd.<span class="built_in">f3</span>(); <span class="comment">//Dervice void f3()</span></span><br><span class="line"></span><br><span class="line">    dd.<span class="built_in">f3</span>(<span class="number">20.1</span>);<span class="comment">//no matching function for call to &#x27;Dervice::f3(double)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到子类的 f1，f2，f3 把父类对应所有的同名函数全部隐藏</p>
<p><strong>如果想要解决这种问题怎么做？</strong></p>
<p>只需要在子类声明一下，父类的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dervice</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::f1;</span><br><span class="line">    <span class="keyword">using</span> Base::f3;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Dervice void f1()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Dervice void f2()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Dervice void f3()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的话，就不会有隐藏的效果了，子类调用一些 f1 同名的函数，但是子类自己没有重写或者覆盖的话，会直接调用到父类对应的函数</p>
<h2 id="34-区分接口继承和实现继承"><a href="#34-区分接口继承和实现继承" class="headerlink" title="34.区分接口继承和实现继承"></a>34.区分接口继承和实现继承</h2><p>接口继承：需要要求子类强制去实现对应接口</p>
<p>（1）<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">纯虚函数</a>只提供接口继承，但可以被实现；<br>（2）<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">虚函数</a>既提供接口继承，也提供了一份默认实现，即也提供实现继承；<br>（3）普通函数既提供接口继承，也提供实现继承。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">d1</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//纯虚函数 提供 接口继承</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">errr</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//接口继承+缺省实现继承</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">obj</span><span class="params">()</span><span class="type">const</span> </span>&#123;&#125; <span class="comment">//提供强制的接口继承和缺省实现继承</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里假定讨论的成员函数都是 public</p>
<p>普通成员函数是将接口与实现都继承下来了，如果在派生类中重定义普通函数，将所有同名函数隐藏。事实上，也是极不推荐在派生类中隐藏基类的普通函数，如果真的要这样做，请一定要考虑是否该把基类的这个函数声明为虚函数或者纯虚函数。</p>
<p><strong>总结：对于不能提供默认实现的，选用接口继承，而可以给出默认实现的选择实现继承</strong></p>
<h2 id="35-考虑虚函数之外其他的选择"><a href="#35-考虑虚函数之外其他的选择" class="headerlink" title="35.考虑虚函数之外其他的选择"></a>35.考虑虚函数之外其他的选择</h2><p><strong>非虚接口（non-virtual interface，NVI），私有虚函数，</strong> 设计手法的核心就是用一个非虚函数作为 wrapper，将虚函数隐藏在封装之下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">HealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ...    <span class="comment">// 做一些前置工作</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">DoHealthValue</span>();</span><br><span class="line">        ...    <span class="comment">// 做一些后置工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">DoHealthValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ...    <span class="comment">// 缺省算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>NVI 手法的一个优点就是在 wrapper (包装器)中做一些前置和后置工作，确保得以在一个虚函数被调用之前设定好适当场景，并在调用结束之后清理场景。如果你让客户直接调用虚函数，就没有任何好办法可以做这些事。</p>
<p><strong>特点：</strong></p>
<p>（1）接口与实现分离，基类负责逻辑和事前事后工作，派生类专心负责数据操作。</p>
<p>（2）基类更加稳定。倘若派生类实现部分改动，只需要重新编译派生类所在文件即可，不影响基类的逻辑部分。基类掌控接口所有权——如果不是 NVI，采用的是普通的虚函数覆盖机制，基类中加入的逻辑判断一旦改动，在所有派生类中的逻辑部分都要改动（因为派生类的 virtual 虚函数会覆盖基类的 virtual 虚函数），这些文件都要重新编译。一定程度上，NVI 的基类集中了对逻辑的掌控，而且不能被子类覆盖，这就是“ public non-virtual ” 接口，不是虚函数的原因。而 virtual 接口是 private 的原因——防止越过“逻辑部分”直接调用 virtual 函数的情况，纯数据操作如果不加入一些逻辑或者线程保护容易出现 bug。</p>
<h2 id="36-绝不重定义继承来的非虚函数"><a href="#36-绝不重定义继承来的非虚函数" class="headerlink" title="36.绝不重定义继承来的非虚函数"></a>36.绝不重定义继承来的非虚函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B temp;</span><br><span class="line">    A *a=&amp;temp;</span><br><span class="line">    a-&gt;<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">    B *b=&amp;temp;</span><br><span class="line">    b-&gt;<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印 A，B；；加上 virtual 之后为 B，B</p>
<p>非虚函数执行静态绑定，根据调用对象本身类型去决定调用什么函数</p>
<p>虚函数执行动态绑定，根据指针所指的真正对象的类型所决定调用什么函数</p>
<h2 id="37-不重新定义继承来的缺省参数"><a href="#37-不重新定义继承来的缺省参数" class="headerlink" title="37.不重新定义继承来的缺省参数"></a>37.不重新定义继承来的缺省参数</h2><p><strong>36 条款说，不重新定义继承的非虚函数，这里依然遵守</strong></p>
<p><strong>虚函数是动态绑定而来，意思是调用一个虚函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个指针所绑定的具体对象的动态类型。但与之不同的是，缺省参数值却是静态绑定，意思是你可能会在“调用一个定义于派生类的虚函数”的同时，却使用基类为它所指定的缺省参数值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">        red,</span><br><span class="line">        green,</span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">string <span class="title">colortostring</span><span class="params">(Color color)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (color)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> Color::red:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;red&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> Color::green:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> Color::blue:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(Color color=Color::red)</span> <span class="type">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Color color = Color::green)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; void Draw(Color color = Color::green) const: &quot;</span>&lt;&lt;<span class="built_in">colortostring</span>(color)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Color color)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; void Draw(Color color) const: &quot;</span>&lt;&lt;<span class="built_in">colortostring</span>(color)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Shape *pr=<span class="keyword">new</span> Rectangle;</span><br><span class="line">    Shape *pc=<span class="keyword">new</span> Circle;</span><br><span class="line"></span><br><span class="line">    pr-&gt;<span class="built_in">Draw</span>();    <span class="comment">//按理说这个应该打印 green</span></span><br><span class="line">    pc-&gt;<span class="built_in">Draw</span>();     <span class="comment">//按理说这个不能调用成功的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​ <strong>pr-&gt;Draw(); &#x2F;&#x2F;按理说这个应该打印 green</strong></p>
<p>​ <strong>pc-&gt;Draw(); &#x2F;&#x2F;按理说这个不能调用成功的</strong></p>
<p><strong>最终结果是：</strong></p>
<p>pr-&gt;Draw();里面 color 参数是 red</p>
<p>pc-&gt;Draw();不仅调用成功，说明给了默认参数，打印出来结果，参数是 red</p>
<p><a href="/../img/Effecitve_C++/1700230094003-2b0c19db-d1e3-406e-bdd8-e8e3ba4a0c34-20251208000346257.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1700230094003-2b0c19db-d1e3-406e-bdd8-e8e3ba4a0c34-20251208000346257.png" alt="img"></a></p>
<p>这说明这两个调用的参数都用的是纯虚函数的参数，因为在编译的时候静态绑定，参数压栈了已经，用的是定义对象的参数，而此时的静态类型是父类的指针或引用。但是执行多态的时候还是调用到了子类的函数，因为父类的指针或引用指向的是子类的对象， 结果展示这样的表现形式其实是有歧义的</p>
<p><strong>改进，利用上面说的 NVI 的思想，并且子类不能重写缺省参数。改写如下</strong></p>
<p><strong>把 Draw 方法改为非虚的，再加一个私有的虚方法 doDraw，让派生类继承之后去重写这个 doDraw 方法，而在父类的 Draw 里面去转调用 doDraw, doDraw 方法也不用给缺省值，只需要给 Draw 给个缺省值就行，派生类各自调用 Draw 就行，调用不给参数的 Draw 就用的默认值，这样就很统一</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">        red,</span><br><span class="line">        green,</span><br><span class="line">        blue</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">string <span class="title">colortostring</span><span class="params">(Color color)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (color)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> Color::red:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;red&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> Color::green:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> Color::blue:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Color color=Color::red)</span> <span class="type">const</span> <span class="comment">//改为非虚函数，里面转调虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">doDraw</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(Color color)</span> <span class="type">const</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doDraw</span><span class="params">(Color color )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; void Rectangle::doDraw() const: &quot;</span>&lt;&lt;<span class="built_in">colortostring</span>(color)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doDraw</span><span class="params">(Color color)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; void Circle:: doDraw() const: &quot;</span>&lt;&lt;<span class="built_in">colortostring</span>(color)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape *pr=<span class="keyword">new</span> Rectangle;</span><br><span class="line">    Shape *pc=<span class="keyword">new</span> Circle;</span><br><span class="line"></span><br><span class="line">    pr-&gt;<span class="built_in">Draw</span>();</span><br><span class="line">    pc-&gt;<span class="built_in">Draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="/../img/Effecitve_C++/1700230694295-49f0777c-e0f5-4cb9-b303-ff0cef3ef272-20251208000346257.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1700230694295-49f0777c-e0f5-4cb9-b303-ff0cef3ef272-20251208000346257.png" alt="img"></a></p>
<h2 id="38-通过组合建模出-has-a-或者实现关系"><a href="#38-通过组合建模出-has-a-或者实现关系" class="headerlink" title="38.通过组合建模出 has-a 或者实现关系"></a>38.通过组合建模出 has-a 或者实现关系</h2><p>所谓的复合指的是某种类型的对象包含它种类型的对象</p>
<p><strong>has-a:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;           <span class="comment">// 合成成分物（composed object）</span></span><br><span class="line">    Address address;            <span class="comment">// 同上</span></span><br><span class="line">    PhoneNumber voiceNumber;    <span class="comment">// 同上</span></span><br><span class="line">    PhoneNumber faxNumber;      <span class="comment">// 同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据某物实现出的关系</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 list 应用于 Set</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; rep;           <span class="comment">// 用来表述 Set 的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="39-明智而审慎地使用-private-继承"><a href="#39-明智而审慎地使用-private-继承" class="headerlink" title="39.明智而审慎地使用 private 继承"></a>39.明智而审慎地使用 private 继承</h2><p><strong>c++里面空类占 1 字节</strong></p>
<h3 id="EBO：空基类优化"><a href="#EBO：空基类优化" class="headerlink" title="EBO：空基类优化"></a>EBO：空基类优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Txt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Empty emy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Txt1</span>:<span class="keyword">public</span> Empty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span> (Empty)&lt;&lt;endl; <span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span> (Txt)&lt;&lt;endl;  <span class="comment">//8</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span> (Txt1)&lt;&lt;endl; <span class="comment">//4  空基类优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Txt，会因为字节对齐，将其原来只占 1 字节，进行扩充到 4 的倍数，最后就是 8 字节。</p>
<p>对比这两个发现，第二种 Txt1 通过继承方式来获得基类的功能，<strong>并没有产生额外大小的优化称之为 EBO(空基类优化)。</strong></p>
<p><strong>所以 EBO 通常就是为了在一些对于类的内存占用有很高要求的场景下使用的，EBO 一般只能在单继承下用</strong></p>
<p><strong>private 继承 就没有了 is-a 的关系，也就是说它没了接口的继承，只剩下了实现的继承</strong></p>
<p>private 继承的特点：</p>
<ol>
<li><strong>如果类之间是 private 继承关系，那么编译器不会自动将一个派生类对象转换为一个基类对象。</strong></li>
</ol>
<p><a href="/../img/Effecitve_C++/1700377281354-45c77175-6b33-4a4e-8126-cfe0dfc5e215-20251208000346412.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1700377281354-45c77175-6b33-4a4e-8126-cfe0dfc5e215-20251208000346412.png" alt="img"></a></p>
<ol>
<li>由 private 继承来的所有成员，在派生类中都会变为 private 属性，换句话说**，private 继承只继承实现，不继承接口。**</li>
</ol>
<p>private 继承的意义是“根据某物实现出”，会发现 private 继承和复合具有相同的意义，事实上也确实如此，绝大部分 private 继承的使用场合都可以被“public 继承+复合”完美解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">private</span> Timer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>替代为： public+复合</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span> : <span class="keyword">public</span> Timer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="40-谨慎使用多重继承"><a href="#40-谨慎使用多重继承" class="headerlink" title="40.谨慎使用多重继承"></a>40.谨慎使用多重继承</h2><p>多重继承会带来符号的歧义性（菱形继承）</p>
<p>用虚继承解决</p>
<p><a href="/../img/Effecitve_C++/1700379028896-f27702b0-8081-4734-9b2c-0058d23e5126-20251208000346415.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1700379028896-f27702b0-8081-4734-9b2c-0058d23e5126-20251208000346415.png" alt="img"></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(Base*base)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(A*a):<span class="built_in">Base</span>(a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(B*b):<span class="built_in">Base</span>(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(C*c):<span class="built_in">Base</span>(c),<span class="built_in">A</span>(c),<span class="built_in">B</span>(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(D*d):<span class="built_in">Base</span>(d),<span class="built_in">C</span>(d)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有菱形继承，虚继承的时候，后续继承比如 C，或者 D 都要有责任去维护 Base 的初始化，按照普通继承来写，C 和 D 的初始化其实都不用去写 Base 的初始化，因为 A 和 B 那里已经维护了，后面就不用了</p>
<p>**用多重继承的时候一般：****多重继承可用于结合 public 继承和 private 继承，public 继承用于提供接口，private 继承用于提供实现：**</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPerson 类指出要实现的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IPerson</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">BirthDate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseID</span> &#123;  ...  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PersonInfo 类有若干已实现的函数</span></span><br><span class="line"><span class="comment">// 可用以实现 IPerson 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PersonInfo</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">TheName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">TheBirthDate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimOpen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimClose</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPerson 类使用多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPerson</span>: <span class="keyword">public</span> IPerson, <span class="keyword">private</span> PersonInfo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CPerson</span><span class="params">(DatabaseID pid)</span>: PersonInfo(pid) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;       <span class="comment">// 实现必要的 IPerson 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> PersonInfo::<span class="built_in">TheName</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">BirthDate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// 实现必要的 IPerson 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> PersonInfo::<span class="built_in">TheBirthDate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重新定义继承而来的虚函数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimOpen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">ValueDelimClose</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="41-了解隐式接口和编译时多态"><a href="#41-了解隐式接口和编译时多态" class="headerlink" title="41.了解隐式接口和编译时多态"></a>41.了解隐式接口和编译时多态</h2><p><strong>类与模板都支持接口和多态。</strong></p>
<p><strong>对于类而言接口是显式的</strong>，以函数签名为中心，<strong>多态则是通过虚函数发生于运行期；</strong></p>
<p>而对<strong>模板参数</strong>而言，<strong>接口是隐式的</strong>，奠基于有效表达式**，多态则是通过模板具现化和函数重载解析**（function overloading resolution）<strong>发生于编译期。</strong></p>
<p><strong>如下模板代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoProcessing</span><span class="params">(T&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>**需要传入的 T****类型的隐式接口要求：**</p>
<ol>
<li><strong>提供一个名为**<strong>size*</strong>*的成员函数</strong>，该函数的返回值可与 int（10 的类型）执行 operator&gt;，或经过隐式转换后可执行 operator&gt;。</li>
<li><strong>必须支持一个**<strong>operator!&#x3D;*</strong>*函数</strong>，接受 T 类型和 someNastyWidget 的类型，或其隐式转换后得到的类型。</li>
</ol>
<h2 id="42-typename-双重含义"><a href="#42-typename-双重含义" class="headerlink" title="42.typename 双重含义"></a>42.typename 双重含义</h2><p>除了定义模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br></pre></td></tr></table></figure>

<p>用在重复的嵌套类型上面，typename 标识之后，他就是个类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> C&amp;container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C::const_iterator *iter;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器不知道 const_iterator 是什么，可能是变量也可能是类型</p>
<p>比如 C 是个 class 类，有可能 const_iterator 就是 C 类里面某个 static 变量，就有可能认为 const_iterator 乘上 iter ，但是这样其实并不是我们的本意</p>
<p><strong>所以想要标识他肯定是个类型，需要加 typename</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> C&amp;container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> C::const_iterator *iter;</span><br><span class="line">	<span class="comment">//const_iterator 是个类型 ，嵌套的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同样地，若嵌套从属名称出现在模板函数声明部分，也需要显式地指明是否为类型名称：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print2nd</span><span class="params">(<span class="type">const</span> C&amp; container, <span class="type">const</span> <span class="keyword">typename</span> C::iterator iter)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>这一规则的例外是，**<strong>typename*</strong>*不可以出现在基类列表内的嵌套从属类型名称之前，也不可以在成员初始化列表中作为基类的修饰符：</strong></p>
<p><strong>Base 基类里面嵌套的 InBaseClass 类，Derived 去继承的话，在继承的列表和成员函数的初始化列表里面都不用 typename 去做显示的标识</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InBaseClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;::InBaseClass &#123;    <span class="comment">// 基类列表中不允许使用 typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">        : Base&lt;T&gt;::InBaseClass(x) &#123;</span>                 <span class="comment">// 成员初始化列表中不允许使用 typename</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::InBaseClass temp;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="/../img/Effecitve_C++/1700396101437-cb8c9ae0-a13b-4d8f-aec8-e9c7b3f3484f-20251208000346489.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Effecitve_C++/1700396101437-cb8c9ae0-a13b-4d8f-aec8-e9c7b3f3484f-20251208000346489.png" alt="img"></a></p>
<p><strong>在类型名称过于复杂时，可以使用**<strong>using*</strong>*或**<strong>typedef*</strong>*来进行简化：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> value_type = <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type  value_type1;</span><br></pre></td></tr></table></figure>

<h2 id="43-如何访问模板基类里的名称"><a href="#43-如何访问模板基类里的名称" class="headerlink" title="43.如何访问模板基类里的名称"></a>43.如何访问模板基类里的名称</h2><p>在非模板类的继承中，我们通常可以在子类的函数里面直接调用父类的方法</p>
<p>但是在模板类里面，用原来的方式去写是无法调用成功的，<strong>编译会报错</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fc</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fc</span>();  <span class="comment">//调用基类的函数，编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是因为直到模板类被真正实例化的之前，编译器并不知道具体的 Base<T>长什么样子，有可能某个 Base<T>是个全特化版本，他里面并不存在 fc()方法，那么子类去继承 ，然后调用，肯定是错误的</p>
<p><strong>为了在模板的继承里面去调用基类方法，有三种方式：</strong></p>
<ol>
<li><strong>调用动作之前加 this</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">fc</span>();  <span class="comment">//调用基类的函数，编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用 using 声明</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Base&lt;T&gt;::fc; <span class="comment">//暴露出来</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fc</span>();  <span class="comment">//调用基类的函数，编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>指明被调函数在基类里(最好别用！！）如果被调用的是虚函数，相当于明确的绑定对象是基类，虚函数动态绑定的作用就会失效了</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base&lt;T&gt;::<span class="built_in">fc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="44-把与参数无关的代码抽离"><a href="#44-把与参数无关的代码抽离" class="headerlink" title="44.把与参数无关的代码抽离"></a>44.把与参数无关的代码抽离</h2><p>模板可以节省时间和避免代码重复，编译器会为填入的每个不同模板参数具现化出一份对应的代码，但长此以外，可能会造成代码膨胀（code bloat），生成浮夸的二进制目标码。</p>
<p>看下面例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, n * n&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实例化会产生三份代码，仅仅只是size_t n这个值不一样</span></span><br><span class="line">array&lt;<span class="type">double</span>,5&gt; v1;</span><br><span class="line">array&lt;<span class="type">double</span>,10&gt; v2;</span><br><span class="line">array&lt;<span class="type">double</span>,20&gt; v3;</span><br></pre></td></tr></table></figure>

<p>把 invert 剥离出来，然后用 private 继承，只体现 具体实现的继承</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">(std::<span class="type">size_t</span> matrixSize)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, n * n&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;  <span class="comment">// private 继承实现，见条款 39</span></span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::Invert;              <span class="comment">// 避免掩盖基类函数，暴露出来，见条款 33</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">Invert</span>(n); &#125;              <span class="comment">// 调用模板基类函数，见条款 43</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Invert 并不是我们唯一要使用的矩阵操作函数，并且在 invert 里面操作的时候肯定会用到具体类型的内存，所以我们可以给基类提供一个指针，可以去访问具体类型的内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n, T* pMem)</span><br><span class="line">        : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123;&#125;        <span class="comment">//把地址传给基类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetDataPtr</span><span class="params">(T* ptr)</span> </span>&#123; pData = ptr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> size;</span><br><span class="line">    T* pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>() : <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data.<span class="built_in">data</span>()) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;T, n * n&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然而这种做法并非永远能取得优势，<strong>硬是绑着矩阵尺寸的那个版本（就是最初的那一版），有可能生成比共享版本更佳的代码。例如在尺寸专属版中，尺寸是个编译期常量，因此可以在编译期藉由常量的广传达到最优化</strong>；<strong>而在共享版本中（后面修改后的两版），不同大小的矩阵只拥有单一版本的函数，可减少可执行文件大小</strong>，<strong>也就因此降低程序的 working set（在“虚内存环境”下执行的进程所使用的一组内存页），并强化指令高速缓存区内的引用集中化（locality of reference），这些都可能使程序执行得更快速</strong>。究竟哪个版本更佳，只能经由具体的测试后决定。</p>
<h2 id="45-运用模板成员函数接收所有兼容类型"><a href="#45-运用模板成员函数接收所有兼容类型" class="headerlink" title="45.运用模板成员函数接收所有兼容类型"></a>45.运用模板成员函数接收所有兼容类型</h2><p>模板针对不同具体类型视为不同实现，在泛型编程里面，我们经常需要把不同类型之间能够做到相互转换</p>
<p>比如我们设计一个 smartptr，可以支持把 middle 类型指针转为或者赋值给 top 类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartptr&lt;top&gt; ptr1 = <span class="built_in">smartptr</span>&lt;middle&gt; (<span class="keyword">new</span> middle)</span><br></pre></td></tr></table></figure>

<p>考虑设计一个智能指针类，而智能指针需要支持不同类型指针之间的隐式转换（如果可以的话），以及普通指针到智能指针的显式转换。很显然，我们需要的是模板拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt; &amp;other) : <span class="built_in">heldPtr</span>(other.<span class="built_in">get</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(U *p)</span>: heldPtr(p)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T * <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heldPtr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>使用**<strong>get*</strong>*获取原始指针，并将在原始指针之间进行类型转换本身提供了一种保障，如果原始指针之间不能隐式转换，那么其对应的智能指针之间的隐式转换会造成编译错误。</strong></p>
<p><strong>C++11 之后可以这么写：</strong></p>
<p><strong>enable_if 判断 is_convertible U 类型指针能不能转为 T 类型指指针，只有可以的时候，enable_if 返回真且对应函数模板存在，才允许用他的模板函数生效。如果是 flase，则编译器会忽略对应函数模板</strong></p>
<p>std::enable_if&lt;std::is_convertible&lt;U _ , T _ &gt;&gt;::type; 在编译时根据类型是否可以隐式转换为另一个类型来选择函数的重载是否存在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">using</span> safeconv=<span class="keyword">typename</span> std::enable_if&lt;std::is_convertible&lt;U * , T * &gt;&gt;::type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U,<span class="keyword">typename</span> = safeconv&lt;U&gt;&gt;</span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt; &amp;other) : <span class="built_in">heldPtr</span>(other.<span class="built_in">get</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U,<span class="keyword">typename</span> = safeconv&lt;U&gt;&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">SmartPtr</span>(U *p): <span class="built_in">heldPtr</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T * <span class="built_in">get</span>() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> heldPtr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>模板构造函数并不会阻止编译器暗自生成默认的构造函数，所以如果你想要控制拷贝构造的方方面面，你必须同时声明泛化拷贝构造函数和普通拷贝构造函数，相同规则也适用于赋值运算符：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr <span class="type">const</span>&amp; r);                <span class="comment">// 拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt;</span></span><br><span class="line"><span class="function">    <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;             <span class="comment">// 泛化拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr <span class="type">const</span>&amp; r);     <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);  <span class="comment">// 泛化拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="46-使用类模板的非成员函数去实现隐式类型的转换"><a href="#46-使用类模板的非成员函数去实现隐式类型的转换" class="headerlink" title="46.使用类模板的非成员函数去实现隐式类型的转换"></a>46.使用类模板的非成员函数去实现隐式类型的转换</h2><p>与 24 条款类似</p>
<p>看示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numerator = <span class="number">0</span>, <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">Numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">Denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(lhs.<span class="built_in">Numerator</span>() * rhs.<span class="built_in">Numerator</span>(), lhs.<span class="built_in">Denominator</span>() * rhs.<span class="built_in">Denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;     <span class="comment">// 无法通过编译！</span></span><br></pre></td></tr></table></figure>

<p>模板实参在推导的过程中，不会进行隐式类型转换</p>
<p>想要让其编译链接通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>将 operator*置为友元，并在类内定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">Numerator</span>() * rhs.<span class="built_in">Numerator</span>(), lhs.<span class="built_in">Denominator</span>() * rhs.<span class="built_in">Denominator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于定义在类内的函数都会暗自成为内联函数，为了降低内联带来的冲击，可以使 operator*调用类外的辅助模板函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Rational</span>;   <span class="comment">//前置声明一下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> Rational&lt;U&gt; <span class="title">DoMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;U&gt;&amp; lhs, <span class="type">const</span> Rational&lt;U&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;U&gt;(lhs.<span class="built_in">Numerator</span>() * rhs.<span class="built_in">Numerator</span>(), lhs.<span class="built_in">Denominator</span>() * rhs.<span class="built_in">Denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,<span class="type">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">doSome</span>(lhs,rhs);  <span class="comment">//调用外部函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="47-使用-traits-classes-获取类型信息"><a href="#47-使用-traits-classes-获取类型信息" class="headerlink" title="47.使用 traits classes 获取类型信息"></a>47.使用 traits classes 获取类型信息</h2><p>在 STL 里面，容器和算法是分开独立设计，他们之间的搭配使用是通过迭代器联系起来的。那么有个问题？就是说如何从迭代器中获取使用的容器元素的类型的呢？<strong>而这一方法就叫萃取</strong></p>
<p><strong>设计一个萃取的类，步骤如下：</strong></p>
<p>1）确认若干我们希望将来可取得的类型相关信息，例如，对于 STL 的迭代器，我们希望取得迭代器所指元素的类型；**<br><strong>2）为该信息选择一个名称，例如，下面我们起名为 value_type；</strong><br>**3）提供一个 template 和一组特化版本（例如，我们下面的 my_iterator_traits），内容包含我们希望支持的类型相关信息。</p>
<p><strong>简单模拟一个 traits classes：</strong></p>
<p><strong>迭代器所指对象类型为 Iter::value_type</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iter</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// typedef typename Iter::value_type  value_type;  //等价</span></span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Iter::value_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 指针特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iter</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_iterator_traits</span>&lt;Iter *&gt;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//typedef  Iter value_type;  //等价</span></span><br><span class="line">    <span class="keyword">using</span> value_type = Iter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给出三个测试函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(int) is called&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(double) is called&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(char) is called&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my_iterator_traits&lt;vector&lt;<span class="type">int</span>&gt;::iterator&gt;::value_type a;</span><br><span class="line">    <span class="built_in">fun</span>(a); <span class="comment">// 输出 fun(int) is called</span></span><br><span class="line">    my_iterator_traits&lt;vector&lt;<span class="type">double</span>&gt;::iterator&gt;::value_type b;</span><br><span class="line">    <span class="built_in">fun</span>(b); <span class="comment">// 输出 fun(double) is called</span></span><br><span class="line">    my_iterator_traits&lt;<span class="type">char</span> *&gt;::value_type c;</span><br><span class="line">    <span class="built_in">fun</span>(c); <span class="comment">// 输出 fun(char) is called</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明 my_iterator_traits 正确从 vector 里面获取了元素类型 ，给到了 value_type，从而才能正确调用函数</p>
<p>看看 STL 里面 vector 迭代器声明的简化版本:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, ...&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> T value_type;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>vector<int>::iterator -&gt; int 就是 T 给到了 value_type，然后会采用 my_iterator_traits 通用版本，里面的 Iter 就是 vector<int>::iterator，然后再到 ::value_type 拿到 int 类型，给到我们自定义的 my_iterator_traits 的 value_type</p>
<p><strong>也就是说：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Iter::value_type;</span><br><span class="line">这句话里面的 <span class="keyword">typename</span> Iter::value_type ，里面的value_type是因为，STL标准容器他有value_type，</span><br><span class="line">我们要通过::作用域获取他，就是下面这个value_type</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> T value_type;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">至于<span class="keyword">using</span> value_type ，这个value_type 是我们自定义的，即我们从vector迭代器里面的value_type拿到类型</span><br><span class="line">给到我们自定义的value_type里面，然后主函数调用</span><br><span class="line">my_iterator_traits&lt;vector&lt;<span class="type">int</span>&gt;::iterator&gt;::value_type a;</span><br></pre></td></tr></table></figure>

<p>这就是萃取这个机制的设计方法</p>
<h2 id="48-认识模板元编程"><a href="#48-认识模板元编程" class="headerlink" title="48.认识模板元编程"></a>48.认识模板元编程</h2><p>模板元程序执行于 C++ 编译期，因此可以将一些工作从运行期转移至编译期。在模板元编程中没有真正意义上的循环，所有循环效果只能藉由递归实现，而递归在模板元编程中是由 <strong>“递归模板具现化（recursive template instantiation）”</strong> 实现的。</p>
<p><strong>计算阶乘的例子：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;            <span class="comment">// Factorial&lt;n&gt; = n * Factorial&lt;n-1&gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;           <span class="comment">// 处理特殊情况：Factorial&lt;0&gt; = 1</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value;</span><br></pre></td></tr></table></figure>

<h2 id="49-认识-new-handler"><a href="#49-认识-new-handler" class="headerlink" title="49.认识 new_handler"></a>49.认识 new_handler</h2><p>当调 operator new 分配内存，没内存分配的时候，默认会抛出异常，老编译器会返回 null 指针，而抛出异常之前，程序会先调用一个 operator new 错误处理函数，名叫 new-handler,会循环，直到找到足够内存为止</p>
<p><strong>new-handler 是一个 typedef</strong>，指向一个无参数值无返回值的函数。我们可以通过 std:: set_new_handler 函数去指定客户想要的 new-handler。<br>set_new_handler 函数接受一个新的 new-handler 参数，返回被替换掉的 new-handler 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">using</span> new_handler = <span class="built_in">void</span>(*)();</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler)</span> <span class="keyword">noexcept</span></span>;    <span class="comment">// 返回值为原来持有的 new-handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个设计良好的 new-handler 函数必须做以下事情之一：</strong></p>
<ul>
<li><strong>让更多的内存可被使用：</strong> 可以让程序一开始执行就分配一大块内存，而后当 new-handler 第一次被调用，将它们释还给程序使用，造成 operator new 的下一次内存分配动作可能成功。</li>
<li><strong>安装另一个 new-handler：</strong> 如果目前这个 new-handler 无法取得更多内存，可以调换为另一个可以完成目标的 new-handler（令 new-handler 修改“会影响 new-handler 行为”的静态或全局数据）。</li>
<li><strong>卸除 new-handler：</strong> 将 nullptr 传给 set_new_handler，这样会使 operator new 在内存分配不成功时抛出异常。</li>
<li><strong>抛出 bad_alloc（或派生自 bad_alloc）的异常：</strong> 这样的异常不会被 operator new 捕捉，因此会被传播到内存分配处。</li>
<li><strong>不返回：</strong> 通常调用 std::abort 或 std::exit。</li>
</ul>
<p>有的时候我们或许会希望在为不同的类分配对象时，使用不同的方式处理内存分配失败情况。这时候使用静态成员是不错的选择：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做和 std::set_new_handler 相同的事情</span></span><br><span class="line"><span class="function">std::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> globalHandler = std::<span class="built_in">set_new_handler</span>(currentHandler);  <span class="comment">// 切换至 Widget 的专属 new-handler</span></span><br><span class="line">    <span class="type">void</span>* ptr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);                           <span class="comment">// 分配内存或抛出异常</span></span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(globalHandler);                        <span class="comment">// 切换回全局的 new-handler</span></span><br><span class="line">    <span class="keyword">return</span> globalHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::new_handler Widget::currentHandler = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>Widget 的客户应该类似这样使用其 new-handling：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutOfMem</span><span class="params">()</span></span>;  <span class="comment">//OutOfMem  分配失败，自定义的处理函数</span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(OutOfMem);</span><br><span class="line"><span class="keyword">auto</span> pw1 = <span class="keyword">new</span> Widget;              <span class="comment">// 若分配失败，则调用 OutOfMem</span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">auto</span> pw2 = <span class="keyword">new</span> Widget;              <span class="comment">// 若分配失败，则抛出异常</span></span><br></pre></td></tr></table></figure>

<p>实现这一方案的代码并不因类的不同而不同，因此对这些代码加以复用是合理的构想。一个简单的做法是建立起一个“mixin”风格的基类，让其派生类继承它们所需的 set_new_handler 和 operator new，并且使用模板确保每一个派生类获得一个实体互异的 currentHandler 成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span> &#123;       <span class="comment">// “mixin”风格的基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    ...                         <span class="comment">// 其它的 operator new 版本，见条款 52</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> globalHandler = std::<span class="built_in">set_new_handler</span>(currentHandler);</span><br><span class="line">    <span class="type">void</span>* ptr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(globalHandler);</span><br><span class="line">    <span class="keyword">return</span> globalHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...                         <span class="comment">// 不必再声明 set_new_handler 和 operator new</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意此处的模板参数 T 并没有真正被当成类型使用，而仅仅是用来区分不同的派生类，使得模板机制为每个派生类具现化出一份对应的 currentHandler。</p>
<p>这个做法用到了所谓的 <strong>CRTP（curious recurring template pattern，奇异递归模板模式）</strong> ，除了在上述设计模式中用到之外，它也被用于实现<strong>静态多态</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Interface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Implementation</span>();      <span class="comment">// 在基类中暴露接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&lt;Derived&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Implementation</span><span class="params">()</span></span>;                                  <span class="comment">// 在派生类中提供实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除了会调用 new-handler 的 operator new 以外，C++ 还保留了传统的“分配失败便返回空指针”的 operator new，称为 nothrow new，通过 std::nothrow 对象来使用它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw1 = <span class="keyword">new</span> Widget;                   <span class="comment">// 如果分配失败，抛出 bad_alloc</span></span><br><span class="line"><span class="keyword">if</span> (pw1 == <span class="literal">nullptr</span>) ...                     <span class="comment">// 这个测试一定失败</span></span><br><span class="line"></span><br><span class="line">Widget* pw2 = <span class="built_in">new</span> (std::nothrow) Widget;    <span class="comment">// 如果分配失败，返回空指针</span></span><br><span class="line"><span class="keyword">if</span> (pw2 == <span class="literal">nullptr</span>) ...                     <span class="comment">// 这个测试可能成功</span></span><br></pre></td></tr></table></figure>

<p>nothrow new 对异常的强制保证性并不高，使用它只能保证 operator new 不抛出异常，而无法保证像 new (std::nothrow) Widget 构造函数 这样的表达式不会导致异常，因此实际上并没有使用 nothrow new 的必要。</p>
<p><strong>CRTP:</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_21107433/article/details/123145236"><strong>https://blog.csdn.net/sinat_21107433&#x2F;article&#x2F;details&#x2F;123145236</strong></a></p>
<h2 id="50-何时替换-new-和-delete-是合理的"><a href="#50-何时替换-new-和-delete-是合理的" class="headerlink" title="50.何时替换 new 和 delete 是合理的"></a>50.何时替换 new 和 delete 是合理的</h2><p>用来检测运行上的错误，收集使用的统计数据，增加分配和归还速度，内存对齐，分配归还共享内存</p>
<h2 id="51-编写-new-和-delete-时需固守常规"><a href="#51-编写-new-和-delete-时需固守常规" class="headerlink" title="51.编写 new 和 delete 时需固守常规"></a>51.编写 new 和 delete 时需固守常规</h2><p>c++ new 的时候传 0 字节，也会返回一个合法指针，很诡异</p>
<p>根据 49.50.的约束，我们可以写出非成员函数版本的 new</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)&#123; <span class="comment">//传入0，当1处理</span></span><br><span class="line">        size=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(...) <span class="comment">// 如果分配成功</span></span><br><span class="line">            <span class="keyword">return</span> ;<span class="comment">// 返回指针指向分配得到的内存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果分配失败</span></span><br><span class="line">        <span class="keyword">auto</span> globalhander=std::<span class="built_in">get_new_handler</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(globalhander)&#123;</span><br><span class="line">            <span class="comment">//调全局的</span></span><br><span class="line">            (*globalhander)();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>operator new 的成员函数版本一般只会分配大小刚好为类的大小的内存空间，但是情况并不总是如此，比如假设我们没有为派生类声明其自己的 operator new，那么派生类会从基类继承 operator new，这就导致派生类可以使用其基类的 new 分配方式，但派生类和基类的大小很多时候是不同的。</p>
<p>处理此情况的最佳做法是将“内存申请量错误”的调用行为改为采用标准的 operator new：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size!= <span class="built_in">sizeof</span>(Base))</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在 operator new 的成员函数版本中我们也不需要检测分配的大小是否为 0 了，因为在条款 39 中我们提到过，非附属对象必须有非零大小，所以 sizeof(Base)无论如何也不能为 0</p>
<h2 id="53-写了-placement-new-也要写-placement-delete"><a href="#53-写了-placement-new-也要写-placement-delete" class="headerlink" title="53.写了 placement new 也要写 placement delete"></a>53.写了 placement new 也要写 placement delete</h2><p>定位 new，在已有的内存上重新构造对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> mem[<span class="number">100</span>];  <span class="comment">//栈上对象</span></span><br><span class="line">	mem[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	mem[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	mem[<span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	mem[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; (<span class="type">void</span>*)mem &lt;&lt; endl;</span><br><span class="line">	A* p = <span class="built_in">new</span> (mem)A;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	p-&gt;~<span class="built_in">A</span>();   <span class="comment">//显示调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）用定位放置 new 操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象。如本例就是在栈上生成一个对象。<br>（2）使用语句 A* p&#x3D;new (mem) A;定位生成对象时，指针 p 和数组名 mem 指向同一片存储区。所以，与其说定位放置 new 操作是申请空间，还不如说是利用已经请好的空间，真正的申请空间的工作是在此之前完成的。<br>（3）使用语句 A *p&#x3D;new (mem) A;定位生成对象时，会自动调用类 A 的构造函数，但是由于对象的空间不会自动释放（对象实际上是借用别人的空间），所以必须显示的调用类的析构函数，如本例中的 p-&gt;~A()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* mem = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span> * <span class="built_in">sizeof</span>(B)];   <span class="comment">//堆上对象</span></span><br><span class="line">cout &lt;&lt; (<span class="type">void</span>*)mem &lt;&lt; endl;</span><br><span class="line">B *p = <span class="built_in">new</span>(mem)B;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">p-&gt;~<span class="built_in">B</span>();</span><br><span class="line"><span class="keyword">delete</span>[]mem;</span><br></pre></td></tr></table></figure>

<p>由于成员函数的名称会掩盖其外部作用域中的相同名称（见条款 33），所以提供 placement new 会导致无法使用正常版本的 operator new，同样道理，派生类中的 operator new 会掩盖全局版本和继承而得的 operator new 版本；<strong>为了解决名字掩盖的问，一个最简单的实现方式是，准备一个基类，内含所有正常形式的 new 和 delete：，然后派生类去继承他，里面再去使用 using 声明式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StadardNewDeleteForms</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// normal new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// placement new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, <span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory, ptr)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nothrow new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp; nt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size,nt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory,<span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dervice</span>:<span class="keyword">public</span> StadardNewDeleteForms</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-10-17</span>
            
                <span>该篇文章被 floki</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/C/'>
                            C++
                        </a>
                    
                        <a href='/tags/%E7%9F%A5%E8%AF%86%E7%B1%BB/'>
                            知识类
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E6%8A%80%E6%9C%AF/'>
                            技术
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='/2025/06/04/RunLoop/'>RunLoop 深入理解</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2024/08/12/CSAPP/">CSAPP-链接</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>




                    

                    <div class="footer">
    
        <span> 
            ☪︎ 2002 

            
                

            
                
                    / <a href="/contact/"> 联系 </a>
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>人生短短3万天，又能留下多少痕迹</span>
            
                <span class="footer-last-span-right"><i><a href=""></a><a href=""></a></i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        wrapEmojis('.paper');
    });
</script>
